# Флоу сервиса

### API
* Создание или обновление пользователя `POST /api/v1/user/`
* Получить баланс конкретного пользователя `GET /api/v1/user/{user_id}/balance`
* Создание сделки `POST /api/v1/deal/` => `{"deal_id": int}`
* Отклонение сделки исполнителем `GET /api/v1/deal/{deal_id}/deny` => `empty response`
  * Если исполнитель не согласен
  * Статус `DealStatus.DENY_PERFORMER`, финальный
* Подтверждение сделки `GET /api/v1/deal/{deal_id}/confirm`
  * Исполнитель согласен
  * Если на балансе хватает денег в валюте сделки, то статус DealStatus.CONFIRM_PERFORMER
    * Создаем отрицательную корректировку заказчику
  * Если не хватает, то DealStatus.WAITING_FOR_PAYMENT. В этом случае надо сделать платеж:
    * Список доступных шлюзов для оплаты `GET /api/v1/payment/gateways`
    * Создание платежа `POST /api/v1/payment`
      * В ответе помимо прочего будет `gateway_data`, в котором будут данные от оплатного шлюза
      * в случае usdt ответ будет содержать кошелек для оплаты
      * Нужно оплатить на этот кошелек
    * Факт успешности платежа будет проверен фоновой задачей
  * В момент проверки платежа мы проверяем есть ли у пользователя сделки в ожидающие оплаты
    в валюте платежа
* Создание диспута `POST /api/v1/deal/{deal_id}/dispute/`
  * Есть проверка на статус
  * Если диспут создан
    * `GET /api/v1/deal/{deal_id}/dispute/close_preformer` - закрыть в пользу исполнителя
      * Создаем корректировку баланса исполнителю
    * `GET /api/v1/deal/{deal_id}/dispute/close_customer` - закрыть в пользу заказчика
      * Создаем корректировку баланса заказчику
* Закрытие сделки `GET /api/v1/deal/{deal_id}/close`
  * Создание корректировки баланса исполнителю


### Tasks
* Проверка платежей `tasks.check_payments` - раз в минуту
  * Достаем список платежей со статусом `PaymentStatus.WAITING`
  * Смотрим на шлюз, для него получаем баланс
  * Если кошелек пополнился, то пополняем баланс клиенту
    * Если после пополнения у клиента есть сделки, то сверяем баланс в валюте сделки с суммой сделки
      * Если баланс больше, то переводим сделку в статус `DealStatus.CONFIRMED`
    * Создаем смартконртакт на главный кошелек `settings.tron_main_wallet`
      * первым делом смотрим удалось ли перевести
      * второй шаг - апдейт статуса
      * третий - кошелька
      * потом идем дальше
      * если на любом из шагов произойдет ошибка, то транзакция откатится,
      ошибка улетит в сентри и в следующий раз проверится еще раз


### Chat
Важное уточнение по поводу кафки ибо она была обязатальна к использованию.
* Во первых - в нашем кейсе (socketio + комнаты + малое колличество людей в комнате)
  от кафки будет больше гемора чем профита ибо никаких плюсов использования кафки
  не будет для двоих клиентов в отдной комнате
* Во вторых. Кафка не работает с asyncio (у нее свой луп) и socket.io. Выдержка из доки:

  ```Note that Kafka currently does not support asyncio, so it cannot be used with the socketio.AsyncServer class.```
#### Описание работы

* Используется socket.io
* При подключении смотрем на auth.token, в котором должен быть `chat_id`
  * Если сделки с этим `chat_id` нет, то отвечаем ошибкой авторизации
  * Если же сделка есть, то сохраняем ее в socketio сессию для данного клиента
  * Отвечаем по одному событию на каждое сообщение, которое было в бд на момент подключения
  * Подключаем клиента к комнате `"{chat_id}"`
* Событие `message`
  * Если сообщение не соответствует схеме - игнорируем
  * Если пользователя из сообщения нет - игнорируем
  * Достаем сделку из сессии клмиента
  * записываем сообщение в бд
  * бродкастим сообщение в комнату `"{chat_id}"`
  * Таким образом все активные клиенты получат сообщение бродкастом, а все новые -
    в момент подключения все из бд

#### Нагрузки
* Проверил на 20 rps: подключение от 5 до 10 сообщений рандомно, отключение. все четко
