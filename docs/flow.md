# Флоу сервиса

### API
* Создание или обновление пользователя `POST /api/v1/user/`
* Получить баланс конкретного пользователя `GET /api/v1/user/{user_id}/balance`
* Создание сделки `POST /api/v1/deal/` => `{"deal_id": int}`
* Отклонение сделки исполнителем `GET /api/v1/deal/{deal_id}/deny` => `empty response`
  * Если исполнитель не согласен
  * Статус `DealStatus.DENY_PERFORMER`, финальный
* Подтверждение сделки `GET /api/v1/deal/{deal_id}/confirm`
  * Исполнитель согласен
  * Если на балансе хватает денег в валюте сделки, то статус DealStatus.CONFIRM_PERFORMER
    * Создаем отрицательную корректировку заказчику
  * Если не хватает, то DealStatus.WAITING_FOR_PAYMENT. В этом случае надо сделать платеж:
    * Список доступных шлюзов для оплаты `GET /api/v1/payment/gateways`
    * Создание платежа `POST /api/v1/payment`
      * В ответе помимо прочего будет `gateway_data`, в котором будут данные от оплатного шлюза
      * в случае usdt ответ будет содержать кошелек для оплаты
      * Нужно оплатить на этот кошелек
    * Факт успешности платежа будет проверен фоновой задачей
  * В момент проверки платежа мы проверяем есть ли у пользователя сделки в ожидающие оплаты
    в валюте платежа
* Создание диспута `POST /api/v1/deal/{deal_id}/dispute/`
  * Есть проверка на статус
  * Если диспут создан
    * `GET /api/v1/deal/{deal_id}/dispute/close_preformer` - закрыть в пользу исполнителя
      * Создаем корректировку баланса исполнителю
    * `GET /api/v1/deal/{deal_id}/dispute/close_customer` - закрыть в пользу заказчика
      * Создаем корректировку баланса заказчику
* Закрытие сделки `GET /api/v1/deal/{deal_id}/close`
  * Создание корректировки баланса исполнителю


### Tasks
* Проверка платежей `tasks.check_payments` - раз в минуту
  * Достаем список платежей со статусом `PaymentStatus.WAITING`
  * Смотрим на шлюз, для него получаем баланс
  * Если кошелек пополнился, то пополняем баланс клиенту
    * Если после пополнения у клиента есть сделки, то сверяем баланс в валюте сделки с суммой сделки
      * Если баланс больше, то переводим сделку в статус `DealStatus.CONFIRMED`
    * Создаем смартконртакт на главный кошелек `settings.tron_main_wallet`
      * первым делом смотрим удалось ли перевести
      * второй шаг - апдейт статуса
      * третий - кошелька
      * потом идем дальше
      * если на любом из шагов произойдет ошибка, то транзакция откатится,
      ошибка улетит в сентри и в следующий раз проверится еще раз
